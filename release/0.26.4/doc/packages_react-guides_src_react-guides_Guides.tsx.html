<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>packages/react-guides/src/react-guides/Guides.tsx - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/daybrush.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="description" content="packages/react-guides/src/react-guides/Guides.tsx - Documentation"/>

</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h2 class="custom"><a href="https://github.com/daybrush/guides" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><div class="search"><div class="input-area"><input type="text"/></div><button></button></div><ul class="classes"><li file="guides" class="parent"><a href="Guides.html">Guides</a><h4><a href="Guides.html#static methods">Static Methods</a></h4><ul class='static methods'><li data-type='method'><a href="Guides.html#.zoomTo">zoomTo</a></li></ul><h4><a href="Guides.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Guides.html#trigger">trigger</a></li><li data-type='method'><a href="Guides.html#setState">setState</a></li><li data-type='method'><a href="Guides.html#scrollGuides">scrollGuides</a></li><li data-type='method'><a href="Guides.html#scroll">scroll</a></li><li data-type='method'><a href="Guides.html#resize">resize</a></li><li data-type='method'><a href="Guides.html#once">once</a></li><li data-type='method'><a href="Guides.html#on">on</a></li><li data-type='method'><a href="Guides.html#off">off</a></li><li data-type='method'><a href="Guides.html#loadGuides">loadGuides</a></li><li data-type='method'><a href="Guides.html#getRulerElement">getRulerElement</a></li><li data-type='method'><a href="Guides.html#getGuides">getGuides</a></li><li data-type='method'><a href="Guides.html#getElement">getElement</a></li><li data-type='method'><a href="Guides.html#forceUpdate">forceUpdate</a></li><li data-type='method'><a href="Guides.html#emit">emit</a></li><li data-type='method'><a href="Guides.html#destroy">destroy</a></li></ul><h4><a href="Guides.html#events">Events</a></h4><ul class='events'><li data-type='event'><a href="Guides.html#.event:requestScroll">requestScroll</a></li><li data-type='event'><a href="Guides.html#.event:dragStart">dragStart</a></li><li data-type='event'><a href="Guides.html#.event:dragEnd">dragEnd</a></li><li data-type='event'><a href="Guides.html#.event:drag">drag</a></li><li data-type='event'><a href="Guides.html#.event:clickRuler">clickRuler</a></li><li data-type='event'><a href="Guides.html#.event:changeGuides">changeGuides</a></li></ul><h4><a href="Guides.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="Guides.html#.OnRequestScroll">OnRequestScroll</a></li><li data-type='typddef'><a href="Guides.html#.OnDragStart">OnDragStart</a></li><li data-type='typddef'><a href="Guides.html#.OnDragEnd">OnDragEnd</a></li><li data-type='typddef'><a href="Guides.html#.OnDrag">OnDrag</a></li><li data-type='typddef'><a href="Guides.html#.OnClickRuler">OnClickRuler</a></li><li data-type='typddef'><a href="Guides.html#.OnChangeGuides">OnChangeGuides</a></li><li data-type='typddef'><a href="Guides.html#.GuidesProps">GuidesProps</a></li><li data-type='typddef'><a href="Guides.html#.GuidesOptions">GuidesOptions</a></li><li data-type='typddef'><a href="Guides.html#.GuidesInterface">GuidesInterface</a></li><li data-type='typddef'><a href="Guides.html#.GuidesEvents">GuidesEvents</a></li><li data-type='typddef'><a href="Guides.html#.GuideOptions">GuideOptions</a></li></ul></li><li file="eventemitter" class="parent"><a href="EventEmitter.html">EventEmitter</a><h4><a href="EventEmitter.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="EventEmitter.html#trigger">trigger</a></li><li data-type='method'><a href="EventEmitter.html#trigger">trigger</a></li><li data-type='method'><a href="EventEmitter.html#once">once</a></li><li data-type='method'><a href="EventEmitter.html#on">on</a></li><li data-type='method'><a href="EventEmitter.html#off">off</a></li><li data-type='method'><a href="EventEmitter.html#emit">emit</a></li></ul><h4><a href="EventEmitter.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="EventEmitter.html#.TargetParam">TargetParam</a></li><li data-type='typddef'><a href="EventEmitter.html#.OnEvent">OnEvent</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventOptions">EventOptions</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventListener">EventListener</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventInfo">EventInfo</a></li><li data-type='typddef'><a href="EventEmitter.html#.EventHash">EventHash</a></li><li data-type='typddef'><a href="EventEmitter.html#.EmitterParam">EmitterParam</a></li></ul></li></ul><ul class="global"><li file="global"  class="parent"><a href="global.html">Global</a><h4><a href="global.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="global.html#getScrollPos">getScrollPos</a></li><li data-type='method'><a href="global.html#getRulerScrollPos">getRulerScrollPos</a></li><li data-type='method'><a href="global.html#getGuideScrollPos">getGuideScrollPos</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">packages/react-guides/src/react-guides/Guides.tsx</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as React from "react";
import Ruler, { PROPERTIES as RULER_PROPERTIES, RulerProps } from "@scena/react-ruler";
import { ref, refs } from "framework-utils";
import DragScroll from "@scena/dragscroll";
import Gesto, { OnDrag, OnDragEnd, OnDragStart } from "gesto";
import { styled } from "react-css-styled";
import { GUIDES, GUIDE, DRAGGING, ADDER, DISPLAY_DRAG, GUIDES_CSS } from "./consts";
import { prefix } from "./utils";
import { hasClass, addClass, removeClass } from "@daybrush/utils";
import { GuidesState, GuidesProps, GuidesInterface } from "./types";
import { getDistElementMatrix, calculateMatrixDist } from "css-to-mat";

const GuidesElement = styled("div", GUIDES_CSS);

export default class Guides extends React.PureComponent&lt;GuidesProps, GuidesState> implements GuidesInterface {
    public static defaultProps: GuidesProps = {
        className: "",
        type: "horizontal",
        zoom: 1,
        style: {},
        snapThreshold: 5,
        snaps: [],
        digit: 0,
        onClickRuler: () => { },
        onChangeGuides: () => { },
        onRequestScroll: () => { },
        onDragStart: () => { },
        onDrag: () => { },
        onDragEnd: () => { },
        displayDragPos: false,
        dragPosFormat: v => v,
        defaultGuides: [],
        lockGuides: false,
        showGuides: true,
        guideStyle: {},
        dragGuideStyle: {},
        guidePosStyle: {},
        defaultGuidesPos: 0,
    };
    public state: GuidesState = {
        guides: [],
    };
    public adderElement!: HTMLElement;
    public scrollPos: number = 0;
    public ruler!: Ruler;
    private managerRef = React.createRef&lt;HTMLElement>();
    private guidesElement!: HTMLElement;
    private displayElement!: HTMLElement;
    private originElement!: HTMLElement;
    private gesto!: Gesto;
    private guideElements: HTMLElement[] = [];
    private _isFirstMove = false;
    private _zoom = 1;
    private _observer: ResizeObserver | null = null;

    constructor(props: GuidesProps) {
        super(props);
        this.state.guides = props.defaultGuides || [];
        this.scrollPos = props.defaultGuidesPos || 0;
    }
    public render() {
        const {
            className,
            type,
            zoom,
            style,
            rulerStyle,
            displayDragPos,
            cspNonce,
            dragGuideStyle,
            guidePosStyle = {}
        } = this.props as Required&lt;GuidesProps>;
        const props = this.props;
        const translateName = this.getTranslateName();
        const rulerProps: RulerProps = {};

        RULER_PROPERTIES.forEach(name => {
            if (name === "style" || name === "warpSelf" || name === "useResizeObserver") {
                return;
            }
            (rulerProps as any)[name] = props[name];
        });

        this._zoom = zoom;
        return &lt;GuidesElement
            ref={this.managerRef}
            cspNonce={cspNonce}
            className={`${prefix("manager", type)} ${className}`}
            style={style}
        >
            &lt;div className={prefix("guide-origin")} ref={ref(this, "originElement")}>&lt;/div>
            &lt;Ruler
                ref={ref(this, "ruler")}
                style={rulerStyle}
                {...rulerProps}
            />
            &lt;div className={GUIDES} ref={ref(this, "guidesElement")} style={{
                transform: `${translateName}(${-this.scrollPos * zoom}px)`,
            }}>
                {displayDragPos &amp;&amp; &lt;div className={DISPLAY_DRAG}
                    ref={ref(this, "displayElement")} style={guidePosStyle || {}} />}
                &lt;div className={ADDER} ref={ref(this, "adderElement")} style={dragGuideStyle} />
                {this.renderGuides()}
            &lt;/div>
        &lt;/GuidesElement>;
    }
    public renderGuides() {
        const props = this.props;
        const {
            type,
            showGuides,
            guideStyle,
            displayGuidePos,
            guidePosStyle = {},
            guidesOffset,
        } = props as Required&lt;GuidesProps>;

        const zoom = this._zoom;
        const translateName = this.getTranslateName();
        const guides = this.state.guides;
        const guidePosFormat = props.guidePosFormat || props.dragPosFormat || (v => v);

        this.guideElements = [];
        if (showGuides) {
            return guides.map((pos, i) => {
                const guidePos = pos + (guidesOffset || 0);

                return (&lt;div className={prefix("guide", type)}
                    ref={refs(this, "guideElements", i)}
                    key={i}
                    data-index={i}
                    data-pos={pos}
                    style={{
                        ...guideStyle,
                        transform: `${translateName}(${guidePos * zoom}px) translateZ(0px)`,
                    }}>
                    {displayGuidePos &amp;&amp; &lt;div className={prefix("guide-pos")} style={guidePosStyle || {}}>
                        {guidePosFormat!(pos)}
                    &lt;/div>}
                &lt;/div>);
            });
        }
        return;
    }
    public componentDidMount() {
        this.gesto = new Gesto(this.managerRef.current!, {
            container: document.body,
        }).on("dragStart", e => {
            const {
                type,
                lockGuides,
            } = this.props;
            const zoom = this._zoom;

            if (lockGuides === true) {
                e.stop();
                return;
            }
            const inputEvent = e.inputEvent;
            const target = inputEvent.target;
            const datas = e.datas;
            const canvasElement = this.ruler.canvasElement;
            const guidesElement = this.guidesElement;
            const isHorizontal = type === "horizontal";
            const originRect = this.originElement.getBoundingClientRect();
            const matrix = getDistElementMatrix(this.managerRef.current!);
            const offsetPos = calculateMatrixDist(matrix, [
                e.clientX - originRect.left,
                e.clientY - originRect.top,
            ]);
            offsetPos[0] -= guidesElement.offsetLeft;
            offsetPos[1] -= guidesElement.offsetTop;
            offsetPos[isHorizontal ? 1 : 0] += this.scrollPos * zoom!;

            datas.offsetPos = offsetPos;
            datas.matrix = matrix;

            let isLockAdd = lockGuides &amp;&amp; lockGuides.indexOf("add") > -1;
            let isLockRemove = lockGuides &amp;&amp; lockGuides.indexOf("remove") > -1;
            let isLockChange = lockGuides &amp;&amp; lockGuides.indexOf("change") > -1;

            if (target === canvasElement) {
                if (isLockAdd) {
                    e.stop();
                    return;
                }
                datas.fromRuler = true;
                datas.target = this.adderElement;
                // add
            } else if (hasClass(target, GUIDE)) {
                if (isLockRemove &amp;&amp; isLockChange) {
                    e.stop();
                    return;
                }
                datas.target = target;
                // change
            } else {
                e.stop();
                return false;
            }
            this.onDragStart(e);
        }).on("drag", this._onDrag).on("dragEnd", this.onDragEnd);

        if (this.props.useResizeObserver) {
            this._observer = new ResizeObserver(this._onCheck);
            this._observer.observe(this.guidesElement, {
                box: "border-box",
            });
            this._observer.observe(this.getRulerElement(), {
                box: "border-box",
            });
        } else {
            this._onCheck();
        }
    }
    public componentWillUnmount() {
        this.gesto.unset();
        this._observer?.disconnect();
    }
    public componentDidUpdate(prevProps: any) {
        const nextGuides = this.props.defaultGuides;

        if (prevProps.defaultGuides !== nextGuides) {
            // to dynamically update guides from code rather than dragging guidelines
            this.setState({ guides: nextGuides || [] });
        }
    }
    /**
     * Load the current guidelines.
     * @memberof Guides
     * @instance
     */
    public loadGuides(guides: number[]) {
        this.setState({
            guides,
        });
    }
    /**
     * Get current guidelines.
     * @memberof Guides
     * @instance
     */
    public getGuides(): number[] {
        return this.state.guides;
    }
    /**
     * Scroll the positions of the guidelines opposite the ruler.
     * @memberof Guides
     * @instance
     */
    public scrollGuides(pos: number, nextZoom = this._zoom) {
        this._zoom = nextZoom;
        const translateName = this.getTranslateName();
        const guidesElement = this.guidesElement;

        this.scrollPos = pos;
        guidesElement.style.transform = `${translateName}(${-pos * nextZoom}px)`;

        const guides = this.state.guides;
        const guidesOffset = this.props.guidesOffset || 0;
        this.guideElements.forEach((el, i) => {
            if (!el) {
                return;
            }
            const guidePos = guides[i] + (guidesOffset || 0);

            el.style.transform = `${translateName}(${guidePos * nextZoom}px) translateZ(0px)`;
            el.style.display = -pos + guidePos &lt; 0 ? "none" : "block";
        });
    }
    /**
     * Set to the next zoom.
     * @memberof Guides
     * @since 0.22.0
     * @param nextZoom - next zoom
     */
    public zoomTo(nextZoom: number) {
        this.scroll(this.getRulerScrollPos(), nextZoom);
        this.scrollGuides(this.getGuideScrollPos(), nextZoom);
    }
    /**
     * Get Guides DOM Element
     * @memberof Guides
     * @instance
     */
    public getElement() {
        return this.managerRef.current!;
    }
    /**
     * Get Ruler DOM Element
     * @memberof Guides
     * @instance
     */
    public getRulerElement() {
        return this.ruler.canvasElement;
    }
    /**
     * Scroll position of guides (horizontal: y, vertical: x)
     */
    public getGuideScrollPos() {
        return this.scrollPos;
    }
    /**
     * Scroll position of the ruler (horizontal: x, vertical: y)
     */
    public getRulerScrollPos() {
        return this.ruler.getScrollPos();
    }
    /**
     * Scroll the position of the ruler.
     * @memberof Guides
     * @instance
     */
    public scroll(pos: number, nextZoom = this._zoom) {
        this._zoom = nextZoom;
        this.ruler.scroll(pos, nextZoom);
    }
    /**
     * Recalculate the size of the ruler.
     * @memberof Guides
     * @instance
     */
    public resize(nextZoom = this._zoom) {
        this.ruler.resize(nextZoom);
    }
    private onDragStart = (e: any) => {
        const { datas, inputEvent } = e;

        this._isFirstMove = true;
        this.movePos(e);

        /**
         * When the drag starts, the dragStart event is called.
         * @memberof Guides
         * @event dragStart
         * @param {OnDragStart} - Parameters for the dragStart event
         */
        this.props.onDragStart!({
            ...e,
            dragElement: datas.target,
        });

        if (!this.gesto.isFlag()) {
            return;
        }
        inputEvent.stopPropagation();
        inputEvent.preventDefault();


        this._startDragScroll(e);
    }
    private _onDrag = (e: any) => {
        if (this._isFirstMove) {
            this._isFirstMove = false;
            addClass(e.datas.target, DRAGGING);
        }
        const nextPos = this.movePos(e);

        /**
         * When dragging, the drag event is called.
         * @memberof Guides
         * @event drag
         * @param {OnDrag} - Parameters for the drag event
         */
        this.props.onDrag!({
            ...e,
            dragElement: e.datas.target,
        });

        if (!this.gesto.isFlag()) {
            this._endDragScroll(e);
            return;
        }

        this._dragScroll(e);
        return nextPos;
    }
    private onDragEnd = (e: OnDragEnd) => {
        const { datas, isDouble, distX, distY } = e;
        const pos = this.movePos(e);
        let guides = this.state.guides;
        const { onChangeGuides, displayDragPos, digit, lockGuides, guidesOffset } = this.props;
        const zoom = this._zoom;
        const guidePos = parseFloat((pos / zoom!).toFixed(digit || 0));
        const baseScrollPos = this.scrollPos - (guidesOffset || 0);

        if (displayDragPos) {
            this.displayElement.style.cssText += `display: none;`;
        }
        removeClass(datas.target, DRAGGING);
        /**
         * When the drag finishes, the dragEnd event is called.
         * @memberof Guides
         * @event dragEnd
         * @param {OnDragEnd} - Parameters for the dragEnd event
         */
        this.props.onDragEnd!({
            ...e,
            dragElement: datas.target,
        });

        this._endDragScroll(e);
        if (datas.fromRuler) {
            if (this._isFirstMove) {
                /**
                 * When click the ruler, the click ruler is called.
                 * @memberof Guides
                 * @event clickRuler
                 * @param {OnClickRuler} - Parameters for the clickRuler event
                 */
                this.props.onClickRuler!({
                    ...e,
                    pos: 0,
                });
            }
            if (guidePos >= baseScrollPos &amp;&amp; guides.indexOf(guidePos) &lt; 0) {
                this.setState({
                    guides: [...guides, guidePos],
                }, () => {
                    /**
                     * The `changeGuides` event occurs when the guideline is added / removed / changed.
                     * @memberof Guides
                     * @event changeGuides
                     * @param {OnChangeGuides} - Parameters for the changeGuides event
                     */
                    onChangeGuides!({
                        guides: this.state.guides,
                        distX,
                        distY,
                        index: guides.length,
                        isAdd: true,
                        isRemove: false,
                        isChange: false,
                    });
                });
            }
        } else {
            const index = parseFloat(datas.target.getAttribute("data-index"));
            let isRemove = false;
            let isChange = false;

            guides = [...guides];

            const guideIndex = guides.indexOf(guidePos);
            if (
                isDouble
                || guidePos &lt; baseScrollPos
                || (guideIndex > -1 &amp;&amp; guideIndex !== index)
            ) {
                if (lockGuides &amp;&amp; (lockGuides === true || lockGuides.indexOf("remove") > -1)) {
                    return;
                }
                guides.splice(index, 1);
                isRemove = true;
            } else if (guideIndex > -1) {
                return;
            } else {
                if (lockGuides &amp;&amp; (lockGuides === true || lockGuides.indexOf("change") > -1)) {
                    return;
                }
                guides[index] = guidePos;
                isChange = true;
            }
            this.setState({
                guides,
            }, () => {
                const nextGuides = this.state.guides;
                onChangeGuides!({
                    distX,
                    distY,
                    guides: nextGuides,
                    isAdd: false,
                    index,
                    isChange,
                    isRemove,
                });
            });
        }
    }
    private movePos(e: any) {
        const { datas, distX, distY } = e;
        const props = this.props;
        const {
            type, snaps, snapThreshold,
            displayDragPos,
            digit,
        } = props;
        const guidesOffset = props.guidesOffset || 0;
        const zoom = this._zoom;
        const dragPosFormat = props.dragPosFormat || (v => v);
        const isHorizontal = type === "horizontal";
        const matrixPos = calculateMatrixDist(datas.matrix, [distX, distY]);
        const offsetPos = datas.offsetPos;
        const offsetX = matrixPos[0] + offsetPos[0];
        const offsetY = matrixPos[1] + offsetPos[1];
        const guidesZoomOffset = guidesOffset * zoom;
        let nextPos = Math.round(isHorizontal ? offsetY : offsetX) - guidesOffset;
        let guidePos = parseFloat((nextPos / zoom!).toFixed(digit || 0));
        const guideSnaps = snaps!.slice().sort((a, b) => {
            return Math.abs(guidePos - a) - Math.abs(guidePos - b);
        });

        if (guideSnaps.length &amp;&amp; Math.abs(guideSnaps[0] * zoom! - nextPos) &lt; snapThreshold!) {
            guidePos = guideSnaps[0];
            nextPos = guidePos * zoom!;
        }
        if (!datas.fromRuler || !this._isFirstMove) {
            if (displayDragPos) {
                const displayPos = type === "horizontal"
                    ? [offsetX, nextPos + guidesZoomOffset]
                    : [nextPos + guidesZoomOffset, offsetY];

                this.displayElement.style.cssText += `display: block;`
                    + `transform: translate(-50%, -50%) `
                    + `translate(${displayPos.map(v => `${v}px`).join(", ")})`;
                this.displayElement.innerHTML = `${dragPosFormat!(guidePos)}`;
            }
            const target = datas.target;


            target.setAttribute("data-pos", guidePos);
            target.style.transform = `${this.getTranslateName()}(${nextPos + guidesOffset * zoom}px)`;
        }

        return nextPos;
    }
    private getTranslateName() {
        return this.props.type === "horizontal" ? "translateY" : "translateX";
    }

    private _startDragScroll(e: OnDragStart) {
        const scrollOptions = this.props.scrollOptions;

        if (!scrollOptions) {
            return;
        }
        const datas = e.datas;
        const dragScroll = new DragScroll();

        datas.dragScroll = dragScroll;
        dragScroll.on("scroll", ({ container, direction }) => {
            /**
             * If scroll can be triggered through drag, the `requestScroll` event is fired.
             * @memberof Guides
             * @event requestScroll
             * @param {OnRequestScroll} - Parameters for the `requestScroll` event
             */
            this.props.onRequestScroll?.({ container, direction });
        }).on("move", ({ offsetX, offsetY, inputEvent }) => {
            this.gesto.scrollBy(offsetX, offsetY, inputEvent.inputEvent, true);
        });
        dragScroll.dragStart(e, {
            container: scrollOptions.container,
        });
    }
    private _dragScroll(e: OnDrag) {
        const scrollOptions = this.props.scrollOptions;

        if (!scrollOptions) {
            return;
        }
        const dragScroll = e.datas.dragScroll as DragScroll;

        dragScroll.drag(e, scrollOptions);
    }
    private _endDragScroll(e: OnDragEnd) {
        e.datas.dragScroll?.dragEnd();
        e.datas.dragScroll = null;
    }
    private _onCheck = () => {
        this.resize();
    }
}
</code></pre>
        </article>
    </section>





<style>


nav li[file="packages/react-guides/src/react-guides/guides"]:after {
    display: none;
}
nav li[file="packages/react-guides/src/react-guides/guides"] h4, nav li[file="packages/react-guides/src/react-guides/guides"] ul {
    display: block;
}
</style>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/daybrush/jsdoc">JSDoc 0.4.7</a> on Tue May 16 2023 01:39:17 GMT+0900 (대한민국 표준시) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/utils.min.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/custom.js"></script>
</body>
</html>
